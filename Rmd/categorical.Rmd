---
title: "Descriptive statistics"
output: html_document
runtime: shiny
---


```{r setup, include=FALSE}
library("ggplot2")
library("plotly")
library("gridExtra")
library("rmarkdown")
library("knitr")
library("pander")
library("shinythemes")
library("readxl")

knitr::opts_chunk$set(echo = TRUE)
 extract <- function(text) {
    text <- gsub(" ", "", text)
    split <- strsplit(text, ",", fixed = FALSE)[[1]]
    as.numeric(split)
 }
 geo.mean <- function(x,na.rm=TRUE){
  x <- x[!is.na(x)]
   if(any(x < 0)){
     stop("geometric mean defined for positive values only\n")
   } else{
     exp(mean(log(x),na.rm=na.rm))
   }
 }
 #plotting theme for ggplot2
.theme<- theme(
  axis.line = element_line(colour = 'gray', size = .75),
  panel.background = element_blank(),
  plot.background = element_blank()
)

```
## Introduction
The first step in looking at data is to describe the data at hand in some clear manner. 


```{r descriptive-stats, echo=FALSE}
sidebarLayout(
  sidebarPanel(
    selectInput(
      inputId = "datachoice",
      label = "Data (Input some data or upload a file)",
      choices = c("Input data","Upload file","Upload .xls/.xslx file"),
      multiple = FALSE,
      selected = NULL##"Input data"
    ),
    hr(),
    conditionalPanel(
    condition = "input.datachoice == 'Input data'",
    textInput("x", "Data", value = "",
    placeholder = "Enter values separated by a comma with decimals as points, e.g. 1.2, 3.14, 3.1417, etc."),
    hr(),
    ),
    conditionalPanel(
    condition = "input.datachoice == 'Upload file'",
    fileInput("file1", "Choose CSV File",
              multiple = TRUE,
              accept = c("text/csv",
                         "text/comma-separated-values,text/plain",
                         ".csv")),
    hr(),
        # Input: Checkbox if file has header ----
    checkboxInput("header", "Header", TRUE),
        
    # Input: Select separator ----
    radioButtons("sep", "Separator",
                  choices = c(Comma = ",",
                              Semicolon = ";",
                              Tab = "\t"),
                  selected = ","),
        
        # Input: Select quotes ----
    radioButtons("quote", "Quote",
                 choices = c(None = "",
                            "Double Quote" = '"',
                            "Single Quote" = "'"),
                selected = '"'),
    ),
    conditionalPanel(
    condition = "input.datachoice == 'Upload .xls/.xslx file'",
    fileInput('file2', 'Choose .xls/.xlsx file',accept = c(".xlsx",".xls"))
      ),
              # Input: Select what to display
     selectInput("variable","Variable:", choices = NULL),
     selectInput("group","Group:", choices = NULL),
     selectInput("plot.type","Plot Type:",
                 list(boxplot = "boxplot", 
                      histogram = "histogram", 
                      density = "density", 
                      bar = "bar",
                      ScatterPlot = "Scatter Plot")),
    checkboxInput("show.points", "show points", FALSE)

    ),
    mainPanel(
      tabsetPanel(type = "tabs",
      tabPanel("Data", 
      DT::dataTableOutput('tbl1')), # Data  
      tabPanel("Location Summary",
      hr(),
      h4("Numerical variables"),
      uiOutput("bartrim"),
      uiOutput("location")),
      tabPanel("Dispersion Summary",
               uiOutput("dispersion")),
      tabPanel("Graphical Display",
               uiOutput("baralpha"),
               plotlyOutput("plots",height = "400px", width = "600px"))
    )
      )
    )
  
d <- reactive({  
  if(!is.null(input$file1)){
    req(input$file1)
    
    tt <- read.csv(input$file1$datapath,
                   header = input$header,
                   sep = input$sep,
                   quote = input$quote)
   
  } 
  if(!is.null(input$file2)){
    req(input$file2)
    tt <- read_excel(input$file2$datapath,1)
  }
  if(is.null(input$file1) & is.null(input$file2)){
  x <- extract(input$x)
  tt<- data.frame(x = x)
  } 
  var.opts<-colnames(tt)
  updateSelectInput(inputId =  "variable", choices = var.opts)
  updateSelectInput(inputId = "group", choices = var.opts)

  return(tt)
})

output$tbl1 <- DT::renderDataTable({
    d()
  })

output$bartrim <- renderUI({
  sliderInput("trim", "Trim level for mean",min = 0, max = 0.5, value = 0)
})

output$location <- renderTable({
  
df1 <- d()
if(ncol(df1)> 1){
find.classes <- sapply(df1,class)
df <- df1[,which((find.classes =="numeric")| (find.classes=="integer"))]
} else{
  df <- df1
}
    ## compute means
   trim <- input$trim
   Means <- apply(df,2,mean,na.rm=TRUE)
   Trim.means <- apply(df,2,mean,na.rm=TRUE,trim = trim)
   Medians <- apply(df,2,median,na.rm=TRUE)
   geo.Means <- apply(df,2,geo.mean,na.rm=TRUE)
   nks <- apply(df,2,function(z) sum(!is.na(z)))
  dt1 <- rbind(nks,Means, Trim.means,Medians, geo.Means)
  rownames(dt1) <- c("n","Mean",paste("Trimmed Mean (",paste(trim*100),"%)",sep = ""),"Median","Geometric Mean")
  t(dt1)
 },rownames = TRUE,digits=3)


output$dispersion <- renderTable({
  df1 <- d()
  if(ncol(df1)> 1){
    find.classes <- sapply(df1,class)
    df <- df1[,which((find.classes =="numeric")| (find.classes=="integer"))]
    } else{
  df <- df1
}
  sds <- apply(df,2,sd,na.rm=TRUE)
  vars <- apply(df,2,var,na.rm=TRUE)
  IQRs <- apply(df,2,IQR,na.rm=TRUE)
  mads <- apply(df,2,mad,na.rm=TRUE)
  ranges <- apply(df,2,range,na.rm=TRUE)
  nks <- apply(df,2,function(z) sum(!is.na(z)))
  dt1 <- rbind(nks,ranges,sds,vars, IQRs, mads)
  rownames(dt1) <- c("n","Min","Max","SD","Variance","IQR","MAD")
  t(dt1)
 },rownames = TRUE,digits = 3)
 
output$baralpha <- renderUI({
      sliderInput("alpha", "Transparency",min = 0, max = 1, value = 1)
})

  #plotting function using ggplot2
output$plots <- renderPlotly({
  if(!is.null(input$file1)| !is.null(input$file2)){
    obj<-list(data=d(),
               variable=input$variable,
               group=input$group)

    plot.obj<-obj
    
    # #conditions for plotting
    # if(is.null(plot.obj)) return()
    # 
    # #make sure variable and group have loaded
    # if(plot.obj$variable == "" | plot.obj$group =="") return()
    
    #plot types
    plot.type<-switch(input$plot.type,
                      "boxplot" 	= geom_boxplot(alpha=input$alpha),
                      "histogram" =  geom_histogram(alpha=input$alpha,position="identity"),
                      "density" 	=	geom_density(alpha=input$alpha),
                      "bar" 		=	geom_bar(position="dodge")
    )
    
    
    if(input$plot.type=="boxplot")	{		##control for 1D or 2D graphs
      p<-ggplot(plot.obj$data,
                aes_string(
                  x 		= plot.obj$group,
                  y 		= plot.obj$variable,
                  fill 	= plot.obj$group # let type determine plotting
                )
      ) + plot.type
      
      if(input$show.points==TRUE)
      {
        p<-p+ geom_point(color='black',alpha=0.5, position = 'jitter')
      }
      
    } else {
      
      p<-ggplot(plot.obj$data,
                aes_string(
                  x 		= plot.obj$variable,
                  fill 	= plot.obj$group,
                  group 	= plot.obj$group
                  #color 	= as.factor(plot.obj$group)
                )
      ) + plot.type
    }
    
    p<-p+labs(
      fill 	= input$group,
      x 		= "",
      y 		= input$variable
    )  +
      .theme 
    ggplotly(p)##print(p)
  }
  
  
  })

```



### Location Measurements
Given a sample of size $n$, consider  independent random variables $X_1, X_2,\ldots, X_n$, each corresponding to one randomly selected observation. Each of these variables has the distribution of the population, with mean $\mu$ and standard deviation $\sigma$.

1- **Arithmetic mean**: The sample mean from a group of observations is an estimate of the population mean $\mu$.  The sample mean is defined to be,

\[
\bar{x}= \frac{1}{n}\sum^n_{i=1}x_i
\]
2- **Trimmed mean**: This mean is computed after discarding given parts of a probability distribution or sample at the high and low end, and typically discarding an equal amount of both. This number of points to be discarded is usually given as a percentage of the total number of points, but may also be given as a fixed number of points. 

- First find $n =$ number of observations.

- Reorder them as ``order statistics'' $X_i$ from the smallest to the largest.

- Find lower case $p=P/100$ = proportion trimmed.

- Compute $np$. If $np$ is an integer use $k=np$ and trim $k$ observations at both ends. $R = \mbox{remaining observations} = n-2k$. The trimmed mean is defined as,

\[
\bar{x}_{k} = \frac{X_{k+1}+X_{k+2}+â€¦+X_{n-k}}{R} 
\]

3- **Median**: Middle value separating the greater and lesser halves of a data set ,
\[
M = X_{(0.5 \times n)}
\]
4- **Geometric Mean**: The geometric mean of a non-empty data set of (positive) numbers is always at most their arithmetic mean. Equality is only obtained when all numbers in the data set are equal; otherwise, the geometric mean is smaller. 
\[
g = \left(\prod^n_{i=1}x_i\right)^{1/n}
\]

### Dispersion Measurements
Given a sample of size $n$, consider  independent random variables $X_1, X_2,\ldots, X_n$, each corresponding to one randomly selected observation. Each of these variables has the distribution of the population, with mean $\mu$ and standard deviation $\sigma$.

1- **Sample standard deviation**: is a measure of the amount of variation or dispersion of a set of values.
\[
s = \sqrt{\frac{1}{n}\sum^n_{i=1}(x_i-\bar{x})^2}
\]
2- **Sample Variance**: is the expectation of the squared deviation of a random variable from its mean. Informally, it measures how far a set of numbers is spread out from their average value. 
\[
s^2 = \frac{1}{n}\sum^n_{i=1}(x_i-\bar{x})^2
\]

3- **Interquartile Range**:  difference between 75th and 25th percentiles, or between upper and lower quartiles,
\[
IQR = X_{(0.75 n)}- X_{0(0.25 n)}
\]

4- **Median absolute deviation** (MAD): Compute the median absolute deviation, i.e., the (lo-/hi-) median of the absolute deviations from the median, and (by default) adjust by a factor for asymptotically normal consistency.

\[
MAD = \mbox{median}_i(|X_i-\mbox{median}(X_i)|)
\]

5- **Range**: the difference between minimum and maximum of all the given arguments.
\[
R = \max X_i - \min X_i
\]

If {\tt na.rm} is {\tt FALSE}, {\tt NA} and {\tt NaN} values in any of the arguments will cause {\tt NA} values to be returned, otherwise {\tt NA} values are ignored.

If you have any question or want to report something.  Send a message to *israel.almodovar@upr.edu* or *maitra@iastate.edu*.
